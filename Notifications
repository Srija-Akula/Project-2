# notifications/models.py
from django.db import models
from django.conf import settings

class Notification(models.Model):
    recipient = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE, related_name='notifications')
    actor = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE, related_name='+', null=True, blank=True)
    verb = models.CharField(max_length=255)  # e.g. "liked", "commented", "sent you a friend request"
    target_content_type = models.ForeignKey('contenttypes.ContentType', null=True, blank=True, on_delete=models.CASCADE)
    target_object_id = models.PositiveIntegerField(null=True, blank=True)
    unread = models.BooleanField(default=True)
    timestamp = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return f'Notif to {self.recipient}: {self.verb}'

# notifications/consumers.py
import json
from channels.generic.websocket import AsyncJsonWebsocketConsumer
from channels.db import database_sync_to_async
from django.contrib.auth.models import AnonymousUser
from rest_framework_simplejwt.tokens import UntypedToken
from django.contrib.auth import get_user_model
from jwt import decode as jwt_decode
from django.conf import settings

User = get_user_model()

class NotificationConsumer(AsyncJsonWebsocketConsumer):
    async def connect(self):
        # expect JWT token as query param ?token=...
        token = self.scope['query_string'].decode().split('token=')[-1] if b'token' in self.scope['query_string'] else None
        user = None
        if token:
            try:
                payload = jwt_decode(token, settings.SIMPLE_JWT['SIGNING_KEY'], algorithms=[settings.SIMPLE_JWT['ALGORITHM']])
                user = await database_sync_to_async(User.objects.get)(id=payload['user_id'])
            except Exception:
                user = None
        if user:
            self.user = user
            self.group_name = f'user_{user.id}'
            await self.channel_layer.group_add(self.group_name, self.channel_name)
            await self.accept()
        else:
            await self.close(code=4001)

    async def disconnect(self, code):
        if hasattr(self, 'group_name'):
            await self.channel_layer.group_discard(self.group_name, self.channel_name)

    async def receive_json(self, content, **kwargs):
        # optional: ping/pong or mark-as-read
        pass

    async def send_notification(self, event):
        # event contains {'type':'send_notification', 'payload': {...} }
        await self.send_json(event['payload'])


When someone likes a post, create a Notification and do:

from asgiref.sync import async_to_sync
from channels.layers import get_channel_layer

def notify_user(recipient_id, payload):
    channel_layer = get_channel_layer()
    async_to_sync(channel_layer.group_send)(
        f'user_{recipient_id}',
        {'type': 'send_notification', 'payload': payload}
    )

